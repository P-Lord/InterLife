# 通俗易懂的常见数据结构讲解—java实现



# 一、稀疏数组



### 1、概念刨析



#### （1）稀疏数组：

当存在大量重复项的二维数组时，建立另外一个二维数组记录其有效的信息（二维数组的总行列数，出现有效值的位置和大小）即可节省空间



#### （2）具体实现方式

比如有二维数组出现如下图症状：



<img src="C:\Users\官二的磊子\AppData\Roaming\Typora\typora-user-images\image-20210407171600446.png" alt="image-20210407171600446" style="zoom:80%;" />



我们则可以用稀疏数组以记录的方式来存储：

![image-20210407172024760](C:\Users\官二的磊子\AppData\Roaming\Typora\typora-user-images\image-20210407172024760.png)

对应的第一行分别记录了二维数组的总行数、总列数、有效值个数；

第二行以后的数组分别记录了二维数组有效值的所在行数、所在列数、有效值大小。



### 2、代码实现

```java
//将二维数组转换为稀疏数组

//1、找出二维数组中的有效值个数
int count = 0;
for (int i = 0; i < twoDimArray.length; i++) {
    for (int j = 0; j < twoDimArray[i].length; j++) {
        if(twoDimArray[i][j]!=0){
            count++;
        }
    }
}

//2、创建初始稀疏数组
int[][] sparArray = new int[count+1][3];
sparArray[0][0] = sparArray.length;
sparArray[0][1] = sparArray[0].length;
sparArray[0][2] = count;


//3、为稀疏数组赋值
int virtual = 0;
for (int i = 0; i < twoDimArray.length; i++) {
    for (int j = 0; j < twoDimArray[i].length; j++) {
        if(twoDimArray[i][j]!=0){
            virtual++;
            sparArray[virtual][0] = i;
            sparArray[virtual][1] = j;
            sparArray[virtual][2] = twoDimArray[i][j];
        }
    }
}
```





# 二、队列



### 1、概念刨析



#### （1）队列：

就像食堂打饭排队一般，先到的先打先离开，后到的后离开，但是不允许中途离开和插队，队伍的长度存在限制。即先进先出，后进后出。



#### （2）具体实现方式

**总体思想：**用取模的方式创造一个环形数组完成队列类的实现。



**队列属性：**队伍存在基本属性头部（front）、尾部（rear）、最大容量（maxsize），存放数据（大小为arrsize）的数组（arr[]）。可以用构造器实现。



**相关判断：**

是否为空：rear == front

是否为满：(rear + 1) % arrsize == front

有效数据个数：(rear + arrsize - front) % arrsize

加入数据rear变化：rear = (rear + 1) % arrsize（rear向后移动）

取出数据front变化：front = (front + 1) % arrsize（front向后移动）



**队列功能：**

队列的增加：先判断是否为满，若不满则直接加在队伍的尾部，将rear后移

队列的删除：先判断是否为空，若不为空则保存在临时变量中返回，将front后移

队列的遍历：先判断是否为空，若不为空则从front开始遍历，遍历的个数未有效数据个数。

​                                                                          

**解释如下：**

初始front = 0；rear = 0;maxSize=3;arrsize=4

数据从数组[0]开始存到[3] 此时front = 0，rear = 3（增加一次数据后移一位，从0到2，加了三次1），此时(rear + 1) %  arrsize == front判定成功为满，该队列现在为 [0] [1] [2]。

<img src="C:\Users\官二的磊子\Desktop\未来村村长\图片\image-20210407195458020.png" style="zoom:50%;" />

删除数据则front = (front + 1) % arrsize，front=1向前移动，虽然[0]上的数据没有删除，但是该队列现在为 [1] [2] [3]，[0]不属于该队列，[3]无数据为空

<img src="C:\Users\官二的磊子\Desktop\未来村村长\图片\image-20210407211157451.png" alt="image-20210407211157451" style="zoom:50%;" />

此时加入数据,rear +1=4% arrsize = 0,新的数据存在[3]中，此时有效数据为（0 - 1 + 4）% 4 = 3

再删除数据，front = 2,继续前移，此时有效数据为（0 - 2 + 4）% 4 = 2 

再加入数据，rear+1=5 % arrsize = 1, front=2，该队列现在为 [2] [3] [0]，因为rear是下一次储存的位置，所以rear只代表尾部，没有定性储存意义。

<img src="C:\Users\官二的磊子\Desktop\未来村村长\图片\image-20210407211304935.png" alt="image-20210407211304935" style="zoom:50%;" />



### 2、代码实现

```java
package 数据结构;

public class QueueArray {
    public static void main(String[] args) {

    Queue queue = new Queue(3);
    queue.add(1);
    queue.add(2);
    queue.add(3);
    queue.show();
    queue.add(4);
    int delNum = queue.del();
        System.out.println("删除的值为：" + delNum);

}

}

class Queue{
    //属性
    int front,rear,maxsize,arrsize;
    int[] arr;

    public Queue(int maxsize) {
        this.front = 0;
        this.rear = 0;
        this.maxsize = maxsize;
        this.arrsize = maxsize + 1;
        this.arr = new int[maxsize + 1];
    }

    //判断
    //是否满
    public boolean isFull(){
        return (rear + 1) % arrsize == front;
    }

    //是否空
    public boolean isNull(){
        return rear == front;
    }

    //有效数据个数
    public int size(){
        return (rear - front + arrsize) % arrsize;
    }

    //添加数据
    public void add(int n){
        if(isFull()){
            System.out.println("队列满");
        }else {
            arr[rear] = n;
            rear = (rear + 1) % arrsize;
        }

    }

    //删除数据
    public int del(){
        int value = 0;

        if(isNull()){
            System.out.println("队列空");
        }else {
            value = arr[front];
            front = (front + 1) % arrsize;
        }
        return value;
    }

    //遍历
    public void show() {

        if (isNull()) {
            System.out.println("队列空");
        } else {
            System.out.println("队列为： ");
            for (int i = front; i < size(); i++) {
                System.out.print(arr[i] + " ");
            }
            System.out.println();
        }
    }
}
```



# 三、单链表



### 1、概念刨析



#### （1）单链表：

单链表是最基本的链表，单链表中的数据不仅储存了其本身，还存着指向下一个数据的内存地址。就像队列里的人依次手拉手，但是该队列可以中途离开，可以插队。



#### （2）具体实现方式



**总体思想：**在表示数据的类中存一个对象next，存的对象next就是该类本身的对象，next与下一个数据共享内存。



**数据属性与功能：**存在数据基本属性+该数据类的对象，用构造器实现。加一个显示方法toString。



**链表属性：**创建数据对象为head作为链表的头部，不存储数据。



**辅助遍历的变量**：temp = head,头部不能动，靠temp = temp.next使temp后移。



**相关判断：**

是否到链表最后：temp.next==null

是否为空：head.next == null



**单链表功能：**

单链表的添加：遍历整个链表，找到合适的位置添加，若该数据主键存在则返回错误。

**1：**

<img src="C:\Users\官二的磊子\Desktop\未来村村长\图片\image-20210407215322282.png" alt="image-20210407215322282" style="zoom:67%;" />



**2：**

<img src="C:\Users\官二的磊子\Desktop\未来村村长\图片\image-20210407214954947.png" alt="image-20210407214954947" style="zoom:67%;" />

单链表的删除：先判断是否为空，然后利用java的垃圾回收机制，遍历找到删除的数据，然后改变该数据上一个数据的next指向该数据的下一个数据。（相当于队列手拉手，其中一个人直接拉下下个人的手，则中间的人自动退出队伍）。如果数据不存在则返回错误。

**1：**

<img src="C:\Users\官二的磊子\Desktop\未来村村长\图片\image-20210407214954947.png" alt="image-20210407214954947" style="zoom:67%;" />



**2：**

<img src="C:\Users\官二的磊子\Desktop\未来村村长\图片\image-20210407215401290.png" alt="image-20210407215401290" style="zoom:67%;" />

单链表的修改：先判断是否为空，然后遍历找到该数据，数据存在则修改，不存在则返回错误

队列的遍历：先判断是否为空，若不为空则输出。遍历过程如下图

**1：**

<img src="C:\Users\官二的磊子\Desktop\未来村村长\图片\image-20210407214714809.png" alt="image-20210407214714809" style="zoom: 67%;" />



**2：**

​                                                                          <img src="C:\Users\官二的磊子\Desktop\未来村村长\图片\image-20210407214743816.png" alt="image-20210407214743816" style="zoom:67%;" />





### 2、代码实现



```java
package 数据结构;

public class LinkedList {
    public static void main(String[] args) {


    singleLinkedList list = new singleLinkedList();
    list.add(new Student(1,"baba"));
    list.add(new Student(6,"mama"));
    list.add(new Student(3,"wawa"));
    list.show();
        System.out.println("===============");
    list.del(3);
    list.show();
        System.out.println("===============");
    list.alter(6,"son");
        System.out.println("===============");
    list.show();

    }

}

class Student{
    int id;
    String name;
    Student next;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public String toString() {
        return "[" +
                "id=" + id +
                ", name='" + name + '\'' +
                ']';
    }
}

class singleLinkedList{

    private Student head = new Student(0,"");
    private Student temp = null;

    //判断是否为空
    public boolean isNull(){
        return head.next == null;
    }

    //添加
    public void add(Student student){
        temp = head;
        while (true) {
            if (temp.next == null) {
                break;
            }else if(temp.next.id > student.id){
                break;
            }else if(temp.next.id == student.id){
                System.out.println("该id已经存在");
                break;
            }
            temp = temp.next;
        }
        Student curStudent = temp.next;
        temp.next = student;
        student.next = curStudent;
    }

    //遍历
    public void show(){
        if(isNull()){
            System.out.println("该链表为空");
            return;
        }
        Student temp = head;

        while (true){
            if(temp.next==null){
                break;
            }else {
                System.out.println(temp.next.toString());
            }
            temp = temp.next;
        }
    }

    //删除
    public Student del(int id){

        if(isNull()){
            System.out.println("该链表为空");
            return null;
        }
        Student temp = head;
        Student delStu = null;
        while (true){
            if(temp.next == null){
                System.out.println("没有找到该数据");
                break;
            }else if(temp.next.id == id){
                delStu = temp.next;
                temp.next = temp.next.next;
                break;
            }
            temp = temp.next;
        }
        return delStu;
    }

    //修改
    public void alter(int id,String name){

        if(isNull()){
            System.out.println("该链表为空");
            return;
        }
        Student temp = head;

        while (true){
            if(temp.next == null){
                System.out.println("没有找到该数据");
                break;
            }else if(temp.next.id == id){
                temp.next.name = name;
                System.out.println("数据已经修改为："+temp.next.toString());
                break;
            }
            temp=temp.next;
        }
    }
}
```





# 四、哈希表



### 1、概念刨析



#### （1）哈希表：

哈希函数：将给出数据转换成固定长度的无规则数据

哈希表：哈希表的结构是数组里面存链表，存在哈希表的数据必须有主键，因为要用哈希函数处理主键得到数据的存储位置。



#### （2）具体实现方式



**总体思想：**建立一个数组类和一个单链表，在数组类中的数组中存放单链表。



**首先建立一个单链表：**依然有head属性和temp属性，单链表的head头部存放数据，每次添加从尾部开始。增删改查功能不变。



**然后建立一个数组类：**包含属性数组（该数组为数据类的对象数组）和数组大小，构造时为数组每一个位置都增加一个空链表对象。具有增删改功能外，还有hash函数方法来处理主键。



**数据的添加：**

先用hash函数方法处理主键，得到对应存储的数组位置，用提前建立的空链表对象的add方法去添加数据。



**数据的遍历：**

用for循环到每一个提前建立的空链表对象，再用该对象的show方法去依次展示数据。



**数据的删除：**

用hash函数处理需要删除的id来找到存储的数组位置，然后再调用提前建立的空链表对象的del方法进行删除



**数据的查找：**

用hash函数处理需要删除的id来找到存储的数组位置，然后再调用提前建立的空链表的查找方法来显示该数据。



### 2、代码实现

```java
package 数据结构;

public class HashT {
    public static void main(String[] args) {

        HashTable hashTable = new HashTable(10);
        hashTable.hsahAdd(new Teacher(1,"苍老师","男"));
        hashTable.hsahAdd(new Teacher(2,"大司马","女"));
        hashTable.hsahAdd(new Teacher(1,"卢本伟","男"));
        hashTable.hsahAdd(new Teacher(1,"马云","男"));
        hashTable.hsahAdd(new Teacher(5,"ppd","女"));
        hashTable.hashShow();
        hashTable.hashDel(5);
        System.out.println("==============");
        hashTable.hashShow();
        hashTable.hashFind(2);


    }
}

//数据
class Teacher{

    int Tno;
    String name;
    String sex;
    Teacher next;

    public Teacher(int tno, String name, String sex) {
        Tno = tno;
        this.name = name;
        this.sex = sex;
    }

    public String toString() {
        return "{" +
                "Tno=" + Tno +
                ", name='" + name + '\'' +
                ", sex='" + sex + '\'' +
                '}';
    }
}

//单链表
class TLinkedlist{

    Teacher head;//创建一个头部

    //判断是否为空
    public boolean isNull(){
        return head == null;
    }

    //添加
    public void add(Teacher teacher){

        if(isNull()){
            head = teacher;
            return;
        }
        Teacher temp = head;
        while (true){
            if(temp.Tno == teacher.Tno){
                System.out.println(teacher.Tno + "号数据已经存在");
                break;
            }else if(temp.next == null){
                temp.next = teacher;
                break;
            }
            temp = temp.next;
        }
    }

    //遍历
    public void show(){

        if(isNull()){
            System.out.println("该链表为空");
            return;
        }
        Teacher temp = head;
        while (true){
            System.out.print(temp.toString() + ">>>");
            if(temp.next == null){
                break;
            }
            temp = temp.next;
        }
        System.out.println();
    }

    //查找
    public void find(int no){

        if(isNull()){
            return;
        }
        Teacher temp = head;
        while (true){

            if(temp.Tno == no){
                System.out.println("=========");
                System.out.print("查找的数据为： ");
                System.out.println(temp.toString());
                System.out.println("=========");
                break;
            }else if (temp.next == null){
                System.out.println("数据不存在");
                break;
            }
            temp = temp.next;
        }
    }

    //删除
    public void del(int no){

        if(isNull()){
            System.out.println("该链表为空");
            return;
        }
        if(head.Tno == no){
            head =null;
            return;
        }

        Teacher temp = head;
        while (true){
            if (temp.next == null){
                System.out.println("数据不存在");
                break;
            }else if(temp.next.Tno == no){
                temp.next = temp.next.next;
                break;
            }
            temp = temp.next;
        }
    }

}

//哈希表
class HashTable{
    int size;
    TLinkedlist[] teachersList;

    public HashTable(int size) {
        this.size = size;
        teachersList = new TLinkedlist[size];
        for (int i = 0; i < size; i++) {
            teachersList[i] = new TLinkedlist();
        }
    }

    public int HashF(int no){
        return no % 10;
    }
    //增加
    public void hsahAdd(Teacher teacher){
        int Hno = HashF(teacher.Tno);
        teachersList[Hno].add(teacher);
    }

    //删除
    public void hashDel(int no){
        int Hno = HashF(no);
        teachersList[Hno].del(no);
    }

    //遍历
    public void hashShow(){
        for (int i = 0; i < size; i++) {
            if(teachersList[i].isNull()){
                System.out.println((i+1) + "号链表为空");
            }else {
                System.out.print((i+1) + "号链表:  ");
                teachersList[i].show();
            }
        }
    }

    //查找
    public void hashFind(int no){
        int Hno = HashF(no);
        teachersList[Hno].find(no);
    }
}
```